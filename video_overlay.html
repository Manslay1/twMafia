<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Twitch Extension Overlay</title>
    <script src="https://extension-files.twitch.tv/helper/v1/twitch-ext.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 10px 10px 10px 0;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            background-color: transparent;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            width: fit-content;
            max-width: 100%;
        }

        .title {
            font-size: 26px;
            margin-bottom: 10px;
            font-weight: bold;
            text-align: left;
            width: 100%;
        }

        .secondary-title {
            font-size: 24px;
            margin-top: 15px;
            margin-bottom: 10px;
            color: #a970ff;
            text-align: left;
            width: 100%;
        }

        .button-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: flex-start;
            width: 100%;
        }

        .button {
            background-color: rgba(145, 71, 255, 0.8);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 18px;
            transition: background-color 0.2s;
            white-space: nowrap;
        }

            .button:hover {
                background-color: rgba(119, 44, 232, 0.9);
            }
    </style>
</head>
<body>
    <div id="main-title" class="title"></div>
    <div id="button-container" class="button-container"></div>
    <div id="secondary-title" class="secondary-title" style="display: none;"></div>
    <div id="secondary-button-container" class="button-container"></div>

    <script>
        let helixToken = null;
        let channelId = null;
        let clientId = null;
        let viewerInfo = null;
        let tokenReceived = false;
        let authData = null;
        let userName = null;

        window.Twitch.ext.onAuthorized(async (auth) => {
            console.log('Extension authorized:', auth);
            console.log('Viewer data:', window.Twitch.ext.viewer);

            if (!auth) {
                console.error('Authorization data is missing');
                return;
            }
            authData = auth;

            if (auth.channelId && auth.helixToken) {
                try {
                    viewerInfo = {
                        userId: auth.userId, //it is opaque
                        isLinked: Twitch.ext.viewer.isLinked,
                        login: auth.login,
                        username: auth.userName || 'anonymous',
                        isBroadcaster: auth.isBroadcaster,
                        isMod: auth.isMod,
                        timestamp: new Date().toISOString()
                    };
                    sendViewerInfo();
                } catch (e) {
                    console.error('Authorization error:', e);
                }
            } else {
                console.error('Authorization failed: missing channelId or helixToken');
            }

            if (Twitch.ext.viewer.isLinked) {
                const endpointUrl = "https://api.twitch.tv/helix/users";
                const url = `${endpointUrl}?id=${Twitch.ext.viewer.id}`;
                const response = await fetch(url, {
                    headers: {
                        "client-id": auth.clientId,
                        Authorization: `Extension ${auth.helixToken}`,
                    },
                });
                const body = await response.json();
                userName = body.data.at(0)?.display_name;
                viewerInfo.login = userName;
                console.log("Username:", userName);
                updateUI({ mainTitle: "Mafia chat game (waiting for streamer)" });
            } else {
                console.error("Twitch username is not linked!");
                updateUI({
                    mainTitle: "Please, share your nickname to the game",
                    buttons: [{ id: 'share', label: 'Share' }]
                });
            }
        });

        // PubSub event listener
        window.Twitch.ext.listen('broadcast', (target, contentType, message) => {
            console.log('Received PubSub message:', message);
            try {
                if (!message) {
                    throw new Error('Message is undefined');
                }

                const msg = typeof message === 'string' ? JSON.parse(message) : message;

                if (msg.event === 'token' && msg.data) {
                    // Получаем JWT токен для работы с Helix API
                    console.log('Received JWT token');
                    helixToken = msg.data.token;
                    channelId = msg.data.channel_id;
                    clientId = msg.data.client_id;
                    tokenReceived = true;
                    if (channelId != authData.channelId) {
                        sendViaHelixPubSub("broadcast", {
                            event: 'invalid_viewer',
                            sender: window.Twitch.ext.viewer.opaqueId,
                            senderName: authData ? authData.login : '',
                            data: viewerInfo
                        });
                    };
                    sendViewerInfo();
                    return;
                }

                if (msg.event === 'config_update' && msg.data) {
                    console.log('Received new config:', msg.data);
                    updateUI(msg.data);
                }
            } catch (e) {
                console.error('Message parse error:', e);
            }
        });

        // Функция отправки информации о зрителе
        function sendViewerInfo() {
            if (!viewerInfo || !tokenReceived) return;

            try {
                // Отправляем через стандартный механизм
                //window.Twitch.ext.send('broadcast', 'application/json', viewerInfo);

                sendViaHelixPubSub("broadcast", {
                    event: 'viewer_connected',
                    sender: window.Twitch.ext.viewer.opaqueId,
                    senderName: authData ? authData.login : viewerInfo.login,
                    data: viewerInfo
                });

                console.log('Viewer info sent thru Helix PubSub');
            } catch (e) {
                console.error('Error sending viewer info:', e);
            }
        }

        async function sendViaHelixPubSub(msgTarget, message) {
            if (!helixToken || !channelId || !clientId) {
                console.error('Helix credentials not available');
                return false;
            }

            try {
                const response = await fetch(
                    "https://api.twitch.tv/helix/extensions/pubsub",
                    {
                        method: "POST",
                        headers: {
                            "Client-ID": clientId,
                            "Authorization": `Bearer ${helixToken}`,
                            "Content-Type": "application/json"
                        },
                        body: JSON.stringify({
                            //target: ["broadcast"],
                            //target: ["whisper-U"+channelId],
                            target: [msgTarget],
                            broadcaster_id: channelId,
                            is_global_broadcast: false,
                            message: JSON.stringify(message)
                        })
                    }
                );

                if (response.status !== 204) {
                    const errorText = await response.text();
                    console.error('Helix PubSub Error:', errorText);
                    return false;
                }

                console.log('Message sent via Helix PubSub using token', helixToken);
                return true;
            } catch (err) {
                console.error('Helix PubSub Request Error:', err);
                return false;
            }
        }

        function updateUI(config) {
            if (!config) {
                console.error('Config is undefined');
                return;
            }

            const mainTitle = document.getElementById('main-title');
            if (config.mainTitle && mainTitle) {
                mainTitle.textContent = config.mainTitle;
            }

            const buttonContainer = document.getElementById('button-container');
            if (buttonContainer) {
                buttonContainer.innerHTML = '';

                if (config.buttons && Array.isArray(config.buttons)) {
                    config.buttons.forEach(button => {
                        if (button.id && button.label) {
                            const btn = document.createElement('button');
                            btn.className = 'button';
                            btn.textContent = button.label;
                            if (button.id === 'share') {
                                btn.onclick = () => window.Twitch.ext.actions.requestIdShare();
                            } else {
                                btn.onclick = () => handleButtonClick(button.id);
                            }
                            buttonContainer.appendChild(btn);
                        }
                    });
                }
            }

            const secondaryTitle = document.getElementById('secondary-title');
            if (secondaryTitle) {
                if (config.secondaryTitle) {
                    secondaryTitle.textContent = config.secondaryTitle;
                    secondaryTitle.style.display = 'block';
                } else {
                    secondaryTitle.style.display = 'none';
                }
            }

            const secondaryButtonContainer = document.getElementById('secondary-button-container');
            if (secondaryButtonContainer) {
                secondaryButtonContainer.innerHTML = '';

                if (config.secondaryButtons && Array.isArray(config.secondaryButtons)) {
                    config.secondaryButtons.forEach(button => {
                        if (button.id && button.label) {
                            const btn = document.createElement('button');
                            btn.className = 'button';
                            btn.textContent = button.label;
                            btn.onclick = () => handleButtonClick(button.id);
                            secondaryButtonContainer.appendChild(btn);
                        }
                    });
                }
            }
        }

        let lastClickTime = 0;

        function handleButtonClick(buttonId) {
            const now = Date.now();
            if (now - lastClickTime < 500) {
                console.log('Click throttled');
                return;
            }
            lastClickTime = now;

            if (!authData) {
                console.error('Authorization data not available');
                return;
            }
            if (!Twitch.ext.viewer.isLinked) {
                console.error('Viewer is not linked');
                return;
            }

            try {
                if (!buttonId) {
                    throw new Error('Button ID is undefined');
                }

                const message = {
                    action: 'button_click',
                    button_id: buttonId,
                    username: authData.userName || 'anonymous',
                    timestamp: new Date().toISOString()
                };

                if (helixToken) {
                    sendViaHelixPubSub("broadcast", {
                        event: 'button_click',
                        sender: window.Twitch.ext.viewer.opaqueId,
                        senderName: authData.login,
                        data: message
                    });
                } else {
                    console.log('Helix token is empty, cannot send click response!');
                }
            } catch (e) {
                console.error('Send button click error:', e);
            }
            console.log('Button clicked:', buttonId);
        }

        document.addEventListener('DOMContentLoaded', () => {
            if (!Twitch.ext.viewer.isLinked) {
                updateUI({
                    mainTitle: "Please, share your nickname to the game",
                    buttons: [{ id: 'share', label: 'Share' }]
                });
            } else {
                updateUI({
                    mainTitle: "Mafia chat game (waiting for streamer)"
                });
            };
        });
    </script>
</body>
</html>